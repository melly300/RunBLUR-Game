<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0">
<title>Runner Game</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  background: #eaf4ff;
  width: 100%;
  height: 100%;
  overflow: hidden;
}
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const bgImage = new Image();
bgImage.src = "background.png";

// sounds
const bgMusic = new Audio("Untitled Project 2.mp3");
bgMusic.loop = true; bgMusic.volume = 0.3;

const stepSound = new Audio("steps.mp3");
stepSound.loop = true; stepSound.volume = 0.2;

let musicStarted=false;

// resize + ground
let groundY = 0;

function getViewportSize(){
  const tg = window.Telegram && window.Telegram.WebApp;
  // если есть Telegram WebApp API, берём высоту вьюпорта оттуда
  if(tg && typeof tg.viewportHeight === "number" && tg.viewportHeight > 0){
    const width =
      window.innerWidth ||
      document.documentElement.clientWidth ||
      document.body.clientWidth ||
      0;
    return { width, height: tg.viewportHeight };
  }

  const width =
    document.documentElement.clientWidth ||
    document.body.clientWidth ||
    window.innerWidth;
  const height =
    document.documentElement.clientHeight ||
    document.body.clientHeight ||
    window.innerHeight;

  return { width, height };
}

function resizeCanvas(){
  const vp = getViewportSize();

  canvas.style.width = vp.width + "px";
  canvas.style.height = vp.height + "px";
  canvas.width = vp.width;
  canvas.height = vp.height;

  groundY = canvas.height * 0.8;
}

window.addEventListener("resize", resizeCanvas);

// подписка на изменение вьюпорта Telegram Mini App, если доступно
if(window.Telegram && window.Telegram.WebApp){
  window.Telegram.WebApp.onEvent("viewportChanged", resizeCanvas);
  window.Telegram.WebApp.ready();
}

resizeCanvas();

// entities
let player={ x:canvas.width*0.3, y:groundY, vy:0, jumping:false, falling:false };
let police={ x:canvas.width*0.15, y:0 };

let obstacles=[];
let coins = [];
let boosts = [];
let invincible = false;
let jumpBoost = false;
let gravity=1;
let score=0;
let level=1;
let baseSpeed=0.008;
let speed=baseSpeed;
let gameOver=false;
let step=0;
let bgOffset=0;
let boostTimeoutId=null;

// input
function jump(){
  if(!player.jumping && !player.falling){
    player.vy = -(jumpBoost ? canvas.height*0.06 : canvas.height*0.04);
    player.jumping=true;
  }
  if(!musicStarted){
    bgMusic.play();
    stepSound.play();
    musicStarted=true;
  }
}
document.addEventListener("keydown",jump);
document.addEventListener("click",jump);
document.addEventListener("touchstart",jump);

// spawn bins
function spawnObstacle(){
  const type = Math.random();

  let h;
  if(type < 0.33){
    h = canvas.height*0.08; // низкое
  } else if(type < 0.66){
    h = canvas.height*0.15; // высокое
  } else {
    h = canvas.height*0.12; // обычное
  }

  obstacles.push({
    x: canvas.width,
    y: groundY,
    w: canvas.width*0.05,
    h: h,
    moving: type > 0.66
  });
}


// coins
function spawnCoin(){
  coins.push({
    x: canvas.width,
    y: groundY - canvas.height*0.15,
    r: 10
  });
}

function spawnBoost(){
  const types = ["speed","jump","shield"];
  boosts.push({
    x: canvas.width,
    y: groundY - canvas.height*0.2,
    type: types[Math.floor(Math.random()*types.length)],
    r: 12
  });
}

function drawCoins(){
  for(let c of coins){
    ctx.fillStyle="gold";
    ctx.beginPath();
    ctx.arc(c.x,c.y,c.r,0,Math.PI*2);
    ctx.fill();
  }
}

function drawBoosts(){
  for(let b of boosts){
    if(b.type==="speed") ctx.fillStyle="red";
    if(b.type==="jump") ctx.fillStyle="blue";
    if(b.type==="shield") ctx.fillStyle="purple";
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fill();
  }
}

const coinInterval = setInterval(spawnCoin, 1500);
const boostInterval = setInterval(spawnBoost, 5000);


// update
function update(){
  if(gameOver) return;

  player.y += player.vy;
  player.vy += gravity;

  if(player.y >= groundY){
    player.y = groundY;
    player.jumping = false;
  }

  police.y = player.y;

  for(let obs of obstacles){
    obs.x -= canvas.width * speed;

    if(obs.moving){
      obs.y = groundY - obs.h + Math.sin(step * 0.1) * 20;
    }

    if(
      !invincible &&
      player.x < obs.x + obs.w &&
      player.x + 40 > obs.x &&
      player.y - 100 < obs.y &&
      player.y > obs.y - obs.h
    ){
      gameOver = true;
      player.falling = true;
      bgMusic.pause();
      stepSound.pause();
      clearInterval(coinInterval);
      clearInterval(boostInterval);
    }
  }

  obstacles = obstacles.filter(o => o.x + o.w > 0);

  // === МОНЕТЫ ===
  coins = coins.filter(c=>{
    if(
      player.x < c.x + c.r &&
      player.x + 40 > c.x - c.r &&
      player.y - 100 < c.y + c.r &&
      player.y > c.y - c.r
    ){
      score += 100;
      return false;
    }
    return c.x > 0;
  });

  // === БУСТЫ ===
  boosts = boosts.filter(b=>{
    if(
      player.x < b.x + b.r &&
      player.x + 40 > b.x - b.r &&
      player.y - 100 < b.y + b.r &&
      player.y > b.y - b.r
    ){
      if(b.type === "speed") speed = baseSpeed + 0.002;
      if(b.type === "jump") jumpBoost = true;
      if(b.type === "shield") invincible = true;

      if(boostTimeoutId) clearTimeout(boostTimeoutId);
      boostTimeoutId = setTimeout(()=>{
        speed = baseSpeed;
        jumpBoost = false;
        invincible = false;
        boostTimeoutId = null;
      },4000);

      return false;
    }
    return b.x > 0;
  });

  score++;
  step++;
  bgOffset -= canvas.width * 0.001;

  if(score % 1500 === 0){
    level++;
    baseSpeed += 0.001;
    if(!boostTimeoutId){
      speed = baseSpeed;
    }
  }
}


// background
function drawBackground(){
    ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
  ctx.fillStyle="#bde7ff";
  // ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="#ccc";
  for(let i=0;i<20;i++){
    let x=(i*220+bgOffset*0.5)%canvas.width;
    ctx.fillRect(x,groundY-220,140,220);
    ctx.fillStyle="#eee";
    for(let y=0;y<5;y++){
      ctx.fillRect(x+20,groundY-200+y*40,25,25);
      ctx.fillRect(x+80,groundY-200+y*40,25,25);
    }
    ctx.fillStyle="#ccc";
  }
}

// player
function drawPlayer(){
  const px=player.x, py=player.y;
  const run=Math.sin(step*0.3)*10;
  const tilt=player.jumping?-0.4:(player.falling?1:0);

  ctx.save();
  ctx.translate(px,py-60);
  ctx.rotate(tilt);

  // legs
  ctx.fillStyle="#1e3fa3";
  ctx.beginPath();
  ctx.ellipse(-6,30-run,7,26,0.3,0,Math.PI*2);
  ctx.ellipse(10,30+run,7,26,-0.3,0,Math.PI*2);
  ctx.fill();

  // body
  ctx.fillStyle="#2563eb";
  ctx.beginPath();
  ctx.ellipse(2,0,16,30,0,0,Math.PI*2);
  ctx.fill();

  // arms
  ctx.beginPath();
  ctx.ellipse(-20,0+run,6,20,0.5,0,Math.PI*2);
  ctx.ellipse(20,0-run,6,20,-0.5,0,Math.PI*2);
  ctx.fill();

  // neck
  ctx.fillStyle="#5a3a1a";
  ctx.fillRect(-4,-35,8,10);

  // head
  ctx.beginPath();
  ctx.arc(0,-50,14,0,Math.PI*2);
  ctx.fill();

  // face
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(-5,-52,2,0,Math.PI*2);
  ctx.arc(5,-52,2,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle="#4a2e15";
  ctx.fillRect(-1,-50,2,5);

  ctx.strokeStyle="#2b1206";
  ctx.beginPath();
  ctx.arc(0,-45,5,0,Math.PI);
  ctx.stroke();

  ctx.fillStyle="#2b1206";
  ctx.beginPath();
  ctx.arc(0,-42,6,0,Math.PI);
  ctx.fill();

  ctx.fillStyle="#5a3a1a";
  ctx.beginPath();
  ctx.arc(-14,-50,3,0,Math.PI*2);
  ctx.arc(14,-50,3,0,Math.PI*2);
  ctx.fill();

  // chain
  ctx.strokeStyle="gold";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.arc(0,-28,8,0,Math.PI);
  ctx.stroke();

  ctx.restore();
}

// police
function drawPolice(){
  const px=police.x, py=police.y;
  const run=Math.sin(step*0.3+1)*10;

  ctx.save();
  ctx.translate(px,py-60);

  // legs
  ctx.fillStyle="#1f2937";
  ctx.beginPath();
  ctx.ellipse(-6,30-run,7,26,0.3,0,Math.PI*2);
  ctx.ellipse(10,30+run,7,26,-0.3,0,Math.PI*2);
  ctx.fill();

  // body
  ctx.fillStyle="#0f172a";
  ctx.beginPath();
  ctx.ellipse(2,0,16,30,0,0,Math.PI*2);
  ctx.fill();

  // badge
  ctx.fillStyle="gold";
  ctx.beginPath();
  ctx.arc(6,-5,3,0,Math.PI*2);
  ctx.fill();

  // arms
  ctx.fillStyle="#0f172a";
  ctx.beginPath();
  ctx.ellipse(-20,0+run,6,20,0.5,0,Math.PI*2);
  ctx.ellipse(20,0-run,6,20,-0.5,0,Math.PI*2);
  ctx.fill();

  // baton
  ctx.fillStyle="#333";
  ctx.fillRect(22,10,5,20);

  // neck
  ctx.fillStyle="#f1c27d";
  ctx.fillRect(-4,-35,8,10);

  // head
  ctx.beginPath();
  ctx.arc(0,-50,14,0,Math.PI*2);
  ctx.fill();

  // cap
  ctx.fillStyle="#000";
  ctx.fillRect(-14,-65,28,6);
  ctx.fillRect(-8,-70,16,5);

  ctx.restore();
}

// bins
function drawObstacles(){
  for(let obs of obstacles){
    ctx.fillStyle="#2f7d32";
    ctx.fillRect(obs.x,obs.y-obs.h,obs.w,obs.h);
    ctx.fillStyle="#3fa34d";
    ctx.fillRect(obs.x+5,obs.y-obs.h+10,obs.w-10,10);
  }
}

// ground
function drawGround(){
  ctx.fillStyle="#555";
  ctx.fillRect(0,groundY,canvas.width,6);
}

// score
function drawScore(){
  ctx.fillStyle="black";
  ctx.font=(canvas.width*0.04)+"px Arial";
  ctx.fillText("Score: "+score+"  Level: "+level,20,40);
}

// loop
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  drawBackground();
  update();
  drawGround();
  drawPolice();
  drawPlayer();
  drawObstacles();
  drawCoins();
  drawBoosts();
  drawScore();

  if(gameOver){
    ctx.fillStyle="black";
    ctx.font=(canvas.width*0.08)+"px Arial";
    ctx.fillText("GAME OVER",canvas.width*0.25,canvas.height*0.5);
  }

  requestAnimationFrame(loop);
}

document.addEventListener("click",()=>{if(gameOver)location.reload();});
document.addEventListener("touchstart",()=>{if(gameOver)location.reload();});

loop();
</script>
</body>
</html>
