<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Runner Rap Game - Fixed Style</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0f172a;
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      touch-action: none; /* Отключаем зум и скролл на мобилках */
      user-select: none;
      -webkit-user-select: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #loading {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 20px;
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="loading">Loading assets...</div>
<canvas id="game"></canvas>

<script>
(function () {
  "use strict";

  // --- AUDIO SYSTEM (FIXED) ------------------------------------------------
  const audioFile = "Untitled Project 2.mp3";
  const bgMusic = new Audio();
  bgMusic.src = audioFile;
  bgMusic.loop = true;
  bgMusic.volume = 0.5;
  
  let musicStarted = false;

  function initAudio() {
    if (musicStarted) return;
    
    // Пытаемся запустить
    bgMusic.play().then(() => {
      musicStarted = true;
      console.log("Music started successfully");
    }).catch((e) => {
      console.warn("Autoplay prevented. Music will start on next interaction.", e);
    });
  }

  // --- ENGINE SETUP --------------------------------------------------------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false }); // Optimisation
  const loading = document.getElementById("loading");
  
  let width, height, groundY;
  
  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    groundY = height * 0.85; // Земля ниже
    loading.style.display = 'none';
  }
  window.addEventListener('resize', resize);
  resize();

  // --- GAME CONSTANTS ------------------------------------------------------
  const GRAVITY = 2800; 
  const JUMP_FORCE = 950;
  const BASE_SPEED = 500; // Стартовая скорость (пикселей в секунду)
  const SCORE_PER_LEVEL = 100; // Очков для повышения уровня
  
  const GameState = { MENU: 0, GAME: 1, GAMEOVER: 2, SHOP: 3 };
  let currentState = GameState.MENU;

  // --- ASSETS & VARIABLES --------------------------------------------------
  // Игрок
  const player = {
    x: 100, // фиксированный X
    y: groundY,
    vy: 0,
    w: 50,
    h: 110,
    isGrounded: true,
    runAnimFrame: 0,
    hat: "none"
  };

  // Полиция
  const police = {
    x: -100, // Сзади игрока
    y: groundY,
    offsetTarget: 120, // Расстояние от игрока
    runAnimFrame: 0
  };

  // Мир
  let obstacles = [];
  let coins = [];
  let particles = []; // Для эффектов
  
  let gameTime = 0;
  let score = 0;
  let displayScore = 0; // Плавный счетчик
  let level = 1;
  let speed = BASE_SPEED;
  let coinsCount = 0;
  
  let obstacleTimer = 0;

  // Shop items
  const shopItems = [
    { id: "bandana", name: "Red Bandana", price: 50, owned: false, color: "#ef4444" },
    { id: "cap", name: "Blue Cap", price: 100, owned: false, color: "#3b82f6" },
    { id: "crown", name: "Gold Crown", price: 300, owned: false, color: "#eab308" }
  ];

  // --- INPUT HANDLING ------------------------------------------------------
  let isJumpPressed = false;

  function handleInput(type, x, y) {
    // Пытаемся включить музыку при любом нажатии
    initAudio();

    if (currentState === GameState.MENU) {
      // Кнопка PLAY
      if (x > width/2 - 100 && x < width/2 + 100 && y > height/2 && y < height/2 + 60) {
        resetGame();
        currentState = GameState.GAME;
      }
      // Кнопка SHOP
      if (x > width/2 - 100 && x < width/2 + 100 && y > height/2 + 80 && y < height/2 + 140) {
        currentState = GameState.SHOP;
      }
    } 
    else if (currentState === GameState.GAME) {
      if (!isJumpPressed) {
        doJump();
        isJumpPressed = true;
      }
    }
    else if (currentState === GameState.GAMEOVER) {
      currentState = GameState.MENU;
    }
    else if (currentState === GameState.SHOP) {
      // Обработка кликов магазина (упрощенно)
      // Кнопка Back
      if (x > 20 && x < 120 && y > 20 && y < 70) {
        currentState = GameState.MENU;
        return;
      }
      // Покупка
      const listStart = 150;
      shopItems.forEach((item, i) => {
        const itemY = listStart + i * 80;
        if (y > itemY && y < itemY + 60 && x > width - 150) {
          if (!item.owned && coinsCount >= item.price) {
            coinsCount -= item.price;
            item.owned = true;
            player.hat = item.id;
          } else if (item.owned) {
            player.hat = item.id;
          }
        }
      });
    }
  }

  function handleInputUp() {
    isJumpPressed = false;
  }

  function doJump() {
    if (player.isGrounded) {
      player.vy = -JUMP_FORCE;
      player.isGrounded = false;
      spawnParticles(player.x + 20, player.y, 5, "#ccc"); // пыль
    }
  }

  window.addEventListener('mousedown', e => handleInput('mouse', e.clientX, e.clientY));
  window.addEventListener('touchstart', e => {
    handleInput('touch', e.touches[0].clientX, e.touches[0].clientY);
    e.preventDefault(); // блокируем зум
  }, {passive: false});
  window.addEventListener('mouseup', handleInputUp);
  window.addEventListener('touchend', handleInputUp);
  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
      initAudio();
      if (currentState === GameState.GAME) doJump();
      if (currentState === GameState.MENU && e.code === 'Enter') {
         resetGame(); currentState = GameState.GAME; 
      }
      if (currentState === GameState.GAMEOVER && e.code === 'Enter') currentState = GameState.MENU;
    }
  });

  // --- GAME LOGIC ----------------------------------------------------------
  function resetGame() {
    score = 0;
    displayScore = 0;
    level = 1;
    speed = BASE_SPEED;
    obstacles = [];
    coins = [];
    particles = [];
    obstacleTimer = 0;
    player.y = groundY;
    player.vy = 0;
    player.isGrounded = true;
    police.x = -150;
  }

  function update(dt) {
    if (currentState !== GameState.GAME) return;

    gameTime += dt;
    
    // 1. Прогрессия и Скорость
    // Плавное обновление счета
    score += speed * dt * 0.05;
    displayScore += (score - displayScore) * 0.1;

    // Расчет уровня и множителя скорости
    const newLevel = Math.floor(score / SCORE_PER_LEVEL) + 1;
    if (newLevel > level) {
      level = newLevel;
      // Всплывашка "LEVEL UP" (упрощенно через частицы или текст в draw)
    }
    
    // Формула: 1 уровень = 1.0, 2 уровень = 1.1, 10 уровень = 1.9 и т.д.
    const targetSpeed = BASE_SPEED * (1 + (level - 1) * 0.1);
    // Плавное ускорение
    speed += (targetSpeed - speed) * dt * 2; 

    // 2. Физика Игрока
    player.vy += GRAVITY * dt;
    player.y += player.vy * dt;

    if (player.y >= groundY) {
      player.y = groundY;
      player.vy = 0;
      player.isGrounded = true;
    } else {
      player.isGrounded = false;
    }

    // Анимация бега зависит от скорости
    player.runAnimFrame += dt * (speed / 40);

    // 3. Полиция (резиновая логика)
    // Полиция стремится держаться на расстоянии police.offsetTarget
    // Если игрок спотыкается (можно добавить механику), полиция догоняет
    let targetPoliceX = player.x - 120;
    police.x += (targetPoliceX - police.x) * dt * 2;
    police.runAnimFrame += dt * (speed / 38); // Полиция бежит чуть иначе

    // 4. Генерация препятствий
    obstacleTimer -= dt;
    if (obstacleTimer <= 0) {
      spawnObstacle();
      // Интервал уменьшается с уровнем, но не меньше 0.8 сек
      let minTime = Math.max(0.8, 1.8 - (level * 0.05));
      let maxTime = Math.max(1.2, 2.5 - (level * 0.05));
      obstacleTimer = minTime + Math.random() * (maxTime - minTime);
    }

    // 5. Обновление объектов
    updateEntities(dt);
  }

  function spawnObstacle() {
    const type = Math.random();
    let obs = { x: width + 50, y: groundY, w: 50, h: 60, passed: false };
    
    if (type > 0.7) { // Высокое препятствие (мусорный бак)
      obs.h = 90;
      obs.w = 60;
      obs.color = "#047857"; // зеленый бак
    } else if (type > 0.4) { // Низкое (барьер)
      obs.h = 50;
      obs.w = 50;
      obs.color = "#dc2626"; // красный барьер
    } else { // Коробка
      obs.h = 40;
      obs.w = 40;
      obs.color = "#d97706";
    }
    obstacles.push(obs);

    // Генерация монет (иногда над препятствием, иногда за ним)
    if (Math.random() > 0.3) {
      let coinY = groundY - obs.h - 60; // Прыжок
      if (Math.random() > 0.5) coinY = groundY - 30; // Бег
      
      coins.push({
        x: width + 50 + (Math.random() > 0.5 ? 0 : 100),
        y: coinY,
        r: 12,
        picked: false
      });
    }
  }

  function updateEntities(dt) {
    // Препятствия
    for (let i = obstacles.length - 1; i >= 0; i--) {
      let o = obstacles[i];
      o.x -= speed * dt;

      // Коллизия (AABB - Axis Aligned Bounding Box)
      // Упрощенная коллизия: хитбокс игрока чуть меньше спрайта
      if (
        player.x + player.w - 15 > o.x && 
        player.x + 15 < o.x + o.w &&
        player.y - 10 > o.y - o.h
      ) {
        gameOver();
      }

      if (o.x < -100) obstacles.splice(i, 1);
    }

    // Монеты
    for (let i = coins.length - 1; i >= 0; i--) {
      let c = coins[i];
      c.x -= speed * dt;
      
      // Дистанция для сбора
      let dx = (player.x + player.w/2) - c.x;
      let dy = (player.y - player.h/2) - c.y;
      if (Math.sqrt(dx*dx + dy*dy) < 45) {
        coinsCount++;
        score += 10; // Бонус к счету
        spawnParticles(c.x, c.y, 10, "#fbbf24");
        coins.splice(i, 1);
      } else if (c.x < -50) {
        coins.splice(i, 1);
      }
    }

    // Частицы
    for (let i = particles.length - 1; i >= 0; i--) {
      let p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function spawnParticles(x, y, count, color) {
    for(let i=0; i<count; i++) {
      particles.push({
        x: x, y: y,
        vx: (Math.random() - 0.5) * 300,
        vy: (Math.random() - 0.5) * 300,
        life: 0.5 + Math.random() * 0.5,
        color: color,
        size: Math.random() * 4 + 2
      });
    }
  }

  function gameOver() {
    currentState = GameState.GAMEOVER;
    // Тряска экрана или эффект удара
  }

  // --- DRAWING ENGINE (IMPROVED) -------------------------------------------
  
  // Хелпер для рисования округлого прямоугольника
  function drawRoundRect(ctx, x, y, w, h, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, r);
    ctx.fill();
  }

  // Хелпер для градиента
  function getGradient(ctx, color1, color2, x, y, h) {
    const grd = ctx.createLinearGradient(x, y, x, y + h);
    grd.addColorStop(0, color1);
    grd.addColorStop(1, color2);
    return grd;
  }

  // Рисование персонажа (процедурная анимация)
  function drawCharacter(ctx, x, y, animFrame, isPlayer = true) {
    ctx.save();
    ctx.translate(x + 25, y); // Центр в ногах
    
    // Параметры анимации
    const runCycle = Math.sin(animFrame);
    const runCycle2 = Math.sin(animFrame + Math.PI); // Вторая нога
    
    // Наклон тела (от скорости)
    const tilt = isPlayer ? (speed / 3000) : 0.2;
    ctx.rotate(tilt);

    // === ИЗМЕНЕНИЕ ЦВЕТА КОЖИ ===
    // Игрок (справа) - темно-коричневый, Полицейский (слева) - светлый
    const skinColor = isPlayer ? "#5c3a21" : "#ffdbac"; 
    
    const pantsColor = isPlayer ? "#1e3a8a" : "#111827"; // Синие джинсы / Черные брюки
    const shirtColor = isPlayer ? "#3b82f6" : "#1f2937"; // Голубая толстовка / Форма
    const shoesColor = isPlayer ? "#fff" : "#000";

    // --- НОГИ (ИСПРАВЛЕННАЯ АНИМАЦИЯ) ---
    function drawLeg(cycle) {
      ctx.save();
      // Бедро - уменьшен угол маха
      ctx.rotate(cycle * 0.5); 
      drawRoundRect(ctx, -6, -45, 12, 45, 6, pantsColor);
      
      // Голень
      ctx.translate(0, -5);
      // Колено - более естественный сгиб. Math.max не дает колену выгибаться вперед.
      let kneeBend = Math.max(0.1, cycle * 1.7);
      
      if (!isPlayer && !player.isGrounded) kneeBend = 0.5; // В полете ноги чуть согнуты
      ctx.rotate(kneeBend);
      drawRoundRect(ctx, -5, 0, 10, 40, 5, pantsColor);
      // Обувь
      ctx.fillStyle = shoesColor;
      ctx.fillRect(-6, 35, 16, 8);
      ctx.restore();
    }

    // Дальняя нога
    ctx.save(); ctx.translate(0, -45); drawLeg(runCycle2); ctx.restore();

    // --- ТЕЛО ---
    const bob = Math.abs(Math.sin(animFrame * 2)) * 5; // Подпрыгивание при беге
    ctx.translate(0, -45 - bob); 
    
    // Торс
    drawRoundRect(ctx, -15, -55, 30, 60, 10, shirtColor);
    // Детали одежды
    if (isPlayer) {
      ctx.fillStyle = "rgba(255,255,255,0.2)";
      ctx.fillRect(-10, -50, 20, 40); // принт
    } else {
      // Значок полиции
      ctx.fillStyle = "#fbbf24";
      ctx.beginPath(); ctx.arc(5, -40, 4, 0, Math.PI*2); ctx.fill();
    }

    // --- ГОЛОВА ---
    ctx.translate(0, -60);
    // Шея
    ctx.fillStyle = skinColor;
    ctx.fillRect(-5, 0, 10, 8);
    // Голова
    ctx.beginPath();
    ctx.arc(0, -15, 16, 0, Math.PI*2);
    ctx.fillStyle = skinColor;
    ctx.fill();
    
    // Лицо
    ctx.fillStyle = "#000";
    // Глаза
    if (isPlayer) {
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.ellipse(4, -18, 4, 3, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "#000";
      ctx.beginPath(); ctx.arc(5, -18, 1.5, 0, Math.PI*2); ctx.fill();
    } else {
      // Злые глаза / очки
      ctx.fillRect(0, -19, 10, 4);
    }
    
    // Кепка / Шляпа (из инвентаря)
    if (isPlayer) {
      if (player.hat === "bandana") {
        ctx.fillStyle = "#ef4444";
        ctx.fillRect(-16, -24, 32, 6);
        ctx.beginPath(); ctx.moveTo(16, -20); ctx.lineTo(24, -10); ctx.lineTo(16, -15); ctx.fill();
      } else if (player.hat === "cap") {
         ctx.fillStyle = "#2563eb";
         ctx.beginPath(); ctx.arc(0, -20, 16, Math.PI, 0); ctx.fill();
         ctx.fillRect(-16, -20, 32, 5);
         ctx.fillRect(0, -18, 20, 4); // козырек
      } else if (player.hat === "crown") {
         ctx.fillStyle = "#eab308";
         ctx.beginPath(); 
         ctx.moveTo(-12, -25); ctx.lineTo(-12, -40); ctx.lineTo(-6, -30); 
         ctx.lineTo(0, -42); ctx.lineTo(6, -30); ctx.lineTo(12, -40); ctx.lineTo(12, -25); 
         ctx.fill();
      }
    } else {
      // Фуражка полицейского
      ctx.fillStyle = "#1e3a8a";
      ctx.fillRect(-17, -25, 34, 10);
      ctx.fillStyle = "#000";
      ctx.fillRect(-17, -20, 36, 4); // козырек
    }

    ctx.translate(0, 60); // Возвращаемся к плечам

    // --- РУКИ ---
    function drawArm(cycle, holdingBaton) {
      ctx.save();
      ctx.translate(0, -50);
      ctx.rotate(cycle * 1.2); // Размах рук больше
      // Плечо
      drawRoundRect(ctx, -4, 0, 8, 25, 4, shirtColor);
      ctx.translate(0, 22);
      ctx.rotate(-0.5); // Локоть согнут
      // Предплечье
      drawRoundRect(ctx, -3, 0, 6, 20, 3, skinColor);
      // Кисть
      ctx.fillStyle = skinColor;
      ctx.beginPath(); ctx.arc(0, 22, 5, 0, Math.PI*2); ctx.fill();
      
      if (holdingBaton) {
        ctx.save();
        ctx.translate(0, 20);
        ctx.rotate(-1.5);
        ctx.fillStyle = "#333";
        ctx.fillRect(-2, -5, 4, 30);
        ctx.restore();
      }
      ctx.restore();
    }

    // Дальняя рука (скрыта за телом немного)
    drawArm(runCycle2, false);
    // Ближняя нога (рисуем поверх тела)
    ctx.translate(0, 45 + bob); // Вернули в центр координат ног
    ctx.save(); ctx.translate(0, -45); drawLeg(runCycle); ctx.restore();
    // Ближняя рука
    ctx.translate(0, -45 - bob);
    drawArm(runCycle, !isPlayer); // Полицейский держит дубинку

    ctx.restore();
  }

  // Рисование мира
  function draw() {
    // 1. Небо (Градиент)
    const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
    skyGrad.addColorStop(0, "#1e1b4b"); // Темно-синий космос
    skyGrad.addColorStop(1, "#4c1d95"); // Фиолетовый горизонт
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, width, height);

    // 2. Параллакс (Город)
    ctx.fillStyle = "#312e81"; // Силуэт города
    const parallaxOffset = (gameTime * speed * 0.1) % 400; // Медленное движение
    for (let i = -1; i < width/50 + 1; i++) {
        let h = 50 + Math.sin(i * 132) * 30 + 50;
        ctx.fillRect(i * 50 - parallaxOffset, groundY - h, 52, h);
    }
    
    // 3. Дорога
    const roadGrad = ctx.createLinearGradient(0, groundY, 0, height);
    roadGrad.addColorStop(0, "#374151");
    roadGrad.addColorStop(1, "#111827");
    ctx.fillStyle = roadGrad;
    ctx.fillRect(0, groundY, width, height - groundY);
    // Разметка
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.lineWidth = 4;
    ctx.setLineDash([40, 60]);
    ctx.lineDashOffset = -(gameTime * speed); // Движение разметки
    ctx.beginPath();
    ctx.moveTo(0, groundY + 40);
    ctx.lineTo(width, groundY + 40);
    ctx.stroke();
    ctx.setLineDash([]);

    // 4. Игровые объекты
    ctx.shadowColor = "rgba(0,0,0,0.5)";
    ctx.shadowBlur = 10;
    
    // Препятствия
    obstacles.forEach(o => {
      // Текстура коробки/ящика
      drawRoundRect(ctx, o.x, o.y - o.h, o.w, o.h, 4, o.color || "#666");
      // Детали (полоски на ящике)
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(o.x + 5, o.y - o.h + 5, o.w - 10, o.h - 10);
      ctx.fillStyle = "rgba(255,255,255,0.1)";
      ctx.fillRect(o.x, o.y - o.h, 5, o.h); // блик
    });

    ctx.shadowBlur = 0;

    // Монеты
    coins.forEach(c => {
      const rot = Math.abs(Math.cos(gameTime * 5)); // Вращение монеты (блик)
      ctx.fillStyle = "#fbbf24";
      ctx.beginPath(); 
      ctx.ellipse(c.x, c.y, c.r * rot, c.r, 0, 0, Math.PI*2); 
      ctx.fill();
      ctx.fillStyle = "#f59e0b";
      ctx.beginPath(); 
      ctx.ellipse(c.x, c.y, c.r * rot * 0.6, c.r * 0.6, 0, 0, Math.PI*2); 
      ctx.fill();
    });

    // Частицы
    particles.forEach(p => {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1.0;
    });

    // 5. Персонажи
    drawCharacter(ctx, police.x, police.y, police.runAnimFrame, false);
    drawCharacter(ctx, player.x, player.y, player.runAnimFrame, true);

    // 6. UI
    drawUI();
  }

  function drawUI() {
    ctx.fillStyle = "#fff";
    ctx.font = "bold 24px 'Segoe UI', sans-serif";
    
    if (currentState === GameState.GAME) {
      ctx.fillText(`Score: ${Math.floor(displayScore)}`, 20, 40);
      ctx.fillText(`Coins: ${coinsCount}`, 20, 70);
      ctx.fillText(`Level: ${level}`, 20, 100);
      
      // Speed bar (визуализация скорости)
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(width - 120, 20, 100, 10);
      ctx.fillStyle = "#0ea5e9";
      let barFill = Math.min(100, (speed - BASE_SPEED) / 5);
      ctx.fillRect(width - 120, 20, barFill, 10);
      ctx.fillStyle = "#fff";
      ctx.font = "12px sans-serif";
      ctx.fillText("SPEED", width - 120, 15);
    }
    
    else if (currentState === GameState.MENU) {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0,0,width,height);
      
      ctx.fillStyle = "#fff";
      ctx.font = "bold 40px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("RUNNER RAP", width/2, height/2 - 100);
      
      // Кнопка Play
      drawRoundRect(ctx, width/2 - 100, height/2, 200, 60, 30, "#10b981");
      ctx.fillStyle = "white";
      ctx.font = "bold 24px sans-serif";
      ctx.fillText("PLAY", width/2, height/2 + 38);
      
      // Кнопка Shop
      drawRoundRect(ctx, width/2 - 100, height/2 + 80, 200, 60, 30, "#3b82f6");
      ctx.fillStyle = "white";
      ctx.fillText("SHOP", width/2, height/2 + 118);

      ctx.font = "16px sans-serif";
      ctx.fillStyle = "#aaa";
      ctx.fillText("Tap screen to enable music", width/2, height - 30);
    }

    else if (currentState === GameState.GAMEOVER) {
      ctx.fillStyle = "rgba(50,0,0,0.8)";
      ctx.fillRect(0,0,width,height);
      
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "bold 50px sans-serif";
      ctx.fillText("BUSTED!", width/2, height/2 - 50);
      
      ctx.font = "30px sans-serif";
      ctx.fillText(`Score: ${Math.floor(score)}`, width/2, height/2 + 20);
      
      ctx.font = "20px sans-serif";
      ctx.fillStyle = "#ccc";
      ctx.fillText("Press Jump or Enter to Menu", width/2, height/2 + 80);
    }

    else if (currentState === GameState.SHOP) {
      ctx.fillStyle = "#1e293b";
      ctx.fillRect(0,0,width,height);
      
      // Back
      drawRoundRect(ctx, 20, 20, 100, 50, 10, "#475569");
      ctx.fillStyle = "white";
      ctx.textAlign = "left";
      ctx.font = "20px sans-serif";
      ctx.fillText("← Back", 35, 52);
      
      ctx.textAlign = "right";
      ctx.fillText(`Coins: ${coinsCount}`, width - 30, 52);

      ctx.textAlign = "center";
      ctx.font = "bold 30px sans-serif";
      ctx.fillText("Black Market", width/2, 60);

      // Items
      shopItems.forEach((item, i) => {
        const y = 150 + i * 80;
        const xStart = width/2 - 150;
        
        ctx.fillStyle = "#334155";
        if (item.id === player.hat) ctx.fillStyle = "#064e3b"; // Выбрано
        
        drawRoundRect(ctx, 20, y, width - 40, 70, 10, ctx.fillStyle);
        
        ctx.textAlign = "left";
        ctx.fillStyle = "white";
        ctx.font = "24px sans-serif";
        ctx.fillText(item.name, 40, y + 42);
        
        // Кнопка купить/выбрать
        const btnColor = item.owned ? (item.id === player.hat ? "#059669" : "#64748b") : "#d97706";
        const btnText = item.owned ? (item.id === player.hat ? "WEARING" : "WEAR") : `${item.price} $`;
        
        drawRoundRect(ctx, width - 140, y + 15, 120, 40, 8, btnColor);
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.font = "bold 16px sans-serif";
        ctx.fillText(btnText, width - 80, y + 40);
      });
    }

    ctx.textAlign = "start"; // Reset
  }

  // --- LOOP ----------------------------------------------------------------
  let lastTime = 0;
  function loop(timestamp) {
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1); // Limit dt
    lastTime = timestamp;

    update(dt);
    draw();
    
    requestAnimationFrame(loop);
  }
  
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
